#!/bin/bash
set -eu

NAME="${0##*/}"

JOB=flanneld
BIN=flanneld
SIGTERM_FOR=15
SIGKILL_FOR=5

RUN_DIR=/var/vcap/sys/run/$JOB
LOG_DIR=/var/vcap/sys/log/$JOB
JOB_DIR=/var/vcap/jobs/$JOB
CERTS_DIR=/var/vcap/data/k8s/certs
PIDFILE=$RUN_DIR/$JOB.pid
exec >>$LOG_DIR/$BIN.log 2>&1

export PATH=/var/vcap/packages/flanneld/:$PATH

start_flanneld() {

  mkdir -p "$RUN_DIR" "$LOG_DIR"
  chown -R vcap:vcap "$RUN_DIR" "$LOG_DIR"

  <% etcd_endpoints = link('etcd').instances.map { |vm| "https://#{vm.address}:#{link('etcd').p('port')}" }.join(',') %>

  modprobe br_netfilter || true

  mkdir -p /dev/net
  mknod /dev/net/tun c 10 200 || true
  echo 1 > /proc/sys/net/ipv4/ip_forward
  mkdir -p /etc/cni/net.d
  rm  /etc/cni/net.d/10-flannel.conf || true
  cat  > /etc/cni/net.d/50-flannel.conflist <<EOL
{
    "name": "flannel-network",
    "plugins": [
	    {
		    "type": "flannel",
		    "delegate": {
			    "hairpinMode": true,
			    "isDefaultGateway": true
		    }
	    },
	    {
		    "type": "portmap",
		    "capabilities": {
			    "portMappings": true
		    }
	    }
    ]
}
EOL


  /var/vcap/packages/flanneld/etcdctl \
    --endpoints <%= etcd_endpoints %> \
    --cert-file $CERTS_DIR/etcd/cert.pem \
    --key-file $CERTS_DIR/etcd/key.pem \
    --ca-file $JOB_DIR/tls/ca/cert.pem \
    set /coreos.com/network/config '{"Network":"<%= p('pod-network-cidr') %>","Backend":{"Type":"vxlan"}}'

  flanneld -etcd-endpoints=<%= etcd_endpoints %> \
    --ip-masq \
    --etcd-certfile=$CERTS_DIR/etcd/cert.pem \
    --etcd-keyfile=$CERTS_DIR/etcd/key.pem \
    --etcd-cafile=$JOB_DIR/tls/ca/cert.pem \
    1>> $LOG_DIR/flanneld.stdout.log \
    2>> $LOG_DIR/flanneld.stderr.log
}

case $1 in
  start)
    mkdir -p $RUN_DIR

    echo "[$(date)] $BIN/$$: starting up..."
    if [[ -f $PIDFILE ]]; then
      PID=$(head -1 $PIDFILE)
      if [[ -n "$PID" ]]; then
        if [[ -e /proc/$PID ]]; then
          echo "[$(date)] $BIN/$$: found pid file $PIDFILE, with pid '$PID' (which is running)"
          exit 1
        fi
        echo "[$(date)] $BIN/$$: found (stale) pid file $PIDFILE, with pid '$PID' (which is defunct)"
      fi
      rm -f $PIDFILE
    fi

    echo $$ > $PIDFILE
    start_flanneld
    echo "[$(date)] $BIN/$$: exec failed!"
    exit 42
    ;;


  stop)
    echo "[$(date)] $BIN/$$: shutting down..."
    if [[ -f $PIDFILE ]]; then
      PID=$(head -1 $PIDFILE)
      if [[ -n "$PID" ]]; then
        if [[ -e /proc/$PID ]]; then
          echo "[$(date)] $BIN/$$: found pid file $PIDFILE, with pid '$PID' (which is running)"
          echo "[$(date)] $BIN/$$: sending SIGTERM for ${SIGTERM_FOR}s, followed by a SIGKILL..."
          for i in $(seq 1 $(expr $SIGTERM_FOR \* 10)); do
            kill -TERM $PID || true
            if [[ ! -e /proc/$PID ]]; then
              echo "[$(date)] $BIN/$$: pid $PID terminated (via SIGTERM)"
              rm -f $PIDFILE
              echo "[$(date)] $BIN/$$: shut down complete"
              exit 0
            fi
            sleep 0.1
          done

          echo "[$(date)] $BIN/$$: pid $PID did not termiante (via SIGTERM) within ${SIGTERM_FOR}s; sending a SIGKILL and waiting ${SIGKILL_FOR}s..."
          for i in $(seq 1 $(expr $SIGKILL_FOR \* 10)); do
            kill -KILL $PID || true
            if [[ ! -e /proc/$PID ]]; then
              echo "[$(date)] $BIN/$$: pid $PID terminated (via SIGKILL)"
              rm -f $PIDFILE
              echo "[$(date)] $BIN/$$: shut down complete"
              exit 0
            fi
            sleep 0.1
          done
          echo "[$(date)] $BIN/$$: pid $PID did not termiante (via SIGKILL) within ${SIGKILL_FOR}s; giving up."
          exit 1
        fi

        echo "[$(date)] $BIN/$$: found (stale) pid file $PIDFILE, with pid '$PID' (which is defunct)"
      fi
      rm -f $PIDFILE
    fi
    echo "[$(date)] $BIN/$$: shut down complete"
    exit 0
    ;;
esac
